// Code generated by counterfeiter. DO NOT EDIT.
package providersfakes

import (
	"context"
	"net/http"
	"sync"

	"github.com/morphysm/famed-github-backend/internal/repositories/github/model"
	"github.com/morphysm/famed-github-backend/internal/repositories/github/providers"
)

type FakeInstallationClient struct {
	AddInstallationStub        func(string, int64) error
	addInstallationMutex       sync.RWMutex
	addInstallationArgsForCall []struct {
		arg1 string
		arg2 int64
	}
	addInstallationReturns struct {
		result1 error
	}
	addInstallationReturnsOnCall map[int]struct {
		result1 error
	}
	CheckInstallationStub        func(string) bool
	checkInstallationMutex       sync.RWMutex
	checkInstallationArgsForCall []struct {
		arg1 string
	}
	checkInstallationReturns struct {
		result1 bool
	}
	checkInstallationReturnsOnCall map[int]struct {
		result1 bool
	}
	DeleteCommentStub        func(context.Context, string, string, int64) error
	deleteCommentMutex       sync.RWMutex
	deleteCommentArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 int64
	}
	deleteCommentReturns struct {
		result1 error
	}
	deleteCommentReturnsOnCall map[int]struct {
		result1 error
	}
	EnrichIssueStub        func(context.Context, string, string, model.Issue) model.EnrichedIssue
	enrichIssueMutex       sync.RWMutex
	enrichIssueArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 model.Issue
	}
	enrichIssueReturns struct {
		result1 model.EnrichedIssue
	}
	enrichIssueReturnsOnCall map[int]struct {
		result1 model.EnrichedIssue
	}
	EnrichIssuesStub        func(context.Context, string, string, []model.Issue) map[int]model.EnrichedIssue
	enrichIssuesMutex       sync.RWMutex
	enrichIssuesArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 []model.Issue
	}
	enrichIssuesReturns struct {
		result1 map[int]model.EnrichedIssue
	}
	enrichIssuesReturnsOnCall map[int]struct {
		result1 map[int]model.EnrichedIssue
	}
	GetCommentsStub        func(context.Context, string, string, int) ([]model.IssueComment, error)
	getCommentsMutex       sync.RWMutex
	getCommentsArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 int
	}
	getCommentsReturns struct {
		result1 []model.IssueComment
		result2 error
	}
	getCommentsReturnsOnCall map[int]struct {
		result1 []model.IssueComment
		result2 error
	}
	GetEnrichedIssuesStub        func(context.Context, string, string, model.IssueState) (map[int]model.EnrichedIssue, error)
	getEnrichedIssuesMutex       sync.RWMutex
	getEnrichedIssuesArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 model.IssueState
	}
	getEnrichedIssuesReturns struct {
		result1 map[int]model.EnrichedIssue
		result2 error
	}
	getEnrichedIssuesReturnsOnCall map[int]struct {
		result1 map[int]model.EnrichedIssue
		result2 error
	}
	GetIssueEventsStub        func(context.Context, string, string, int) ([]model.IssueEvent, error)
	getIssueEventsMutex       sync.RWMutex
	getIssueEventsArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 int
	}
	getIssueEventsReturns struct {
		result1 []model.IssueEvent
		result2 error
	}
	getIssueEventsReturnsOnCall map[int]struct {
		result1 []model.IssueEvent
		result2 error
	}
	GetIssuePullRequestStub        func(context.Context, string, string, int) (*string, error)
	getIssuePullRequestMutex       sync.RWMutex
	getIssuePullRequestArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 int
	}
	getIssuePullRequestReturns struct {
		result1 *string
		result2 error
	}
	getIssuePullRequestReturnsOnCall map[int]struct {
		result1 *string
		result2 error
	}
	GetIssuesByRepoStub        func(context.Context, string, string, []string, *model.IssueState) ([]model.Issue, error)
	getIssuesByRepoMutex       sync.RWMutex
	getIssuesByRepoArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 []string
		arg5 *model.IssueState
	}
	getIssuesByRepoReturns struct {
		result1 []model.Issue
		result2 error
	}
	getIssuesByRepoReturnsOnCall map[int]struct {
		result1 []model.Issue
		result2 error
	}
	GetRateLimitStub        func(context.Context, string) (model.RateLimit, error)
	getRateLimitMutex       sync.RWMutex
	getRateLimitArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	getRateLimitReturns struct {
		result1 model.RateLimit
		result2 error
	}
	getRateLimitReturnsOnCall map[int]struct {
		result1 model.RateLimit
		result2 error
	}
	GetReposStub        func(context.Context, string) ([]string, error)
	getReposMutex       sync.RWMutex
	getReposArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	getReposReturns struct {
		result1 []string
		result2 error
	}
	getReposReturnsOnCall map[int]struct {
		result1 []string
		result2 error
	}
	GetUserStub        func(context.Context, string, string) (model.User, error)
	getUserMutex       sync.RWMutex
	getUserArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}
	getUserReturns struct {
		result1 model.User
		result2 error
	}
	getUserReturnsOnCall map[int]struct {
		result1 model.User
		result2 error
	}
	PostCommentStub        func(context.Context, string, string, int, string) error
	postCommentMutex       sync.RWMutex
	postCommentArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 int
		arg5 string
	}
	postCommentReturns struct {
		result1 error
	}
	postCommentReturnsOnCall map[int]struct {
		result1 error
	}
	PostLabelStub        func(context.Context, string, string, model.Label) error
	postLabelMutex       sync.RWMutex
	postLabelArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 model.Label
	}
	postLabelReturns struct {
		result1 error
	}
	postLabelReturnsOnCall map[int]struct {
		result1 error
	}
	PostLabelsStub        func(context.Context, string, []string, map[string]model.Label) []error
	postLabelsMutex       sync.RWMutex
	postLabelsArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 []string
		arg4 map[string]model.Label
	}
	postLabelsReturns struct {
		result1 []error
	}
	postLabelsReturnsOnCall map[int]struct {
		result1 []error
	}
	UpdateCommentStub        func(context.Context, string, string, int64, string) error
	updateCommentMutex       sync.RWMutex
	updateCommentArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 int64
		arg5 string
	}
	updateCommentReturns struct {
		result1 error
	}
	updateCommentReturnsOnCall map[int]struct {
		result1 error
	}
	ValidateWebHookEventStub        func(*http.Request) (interface{}, error)
	validateWebHookEventMutex       sync.RWMutex
	validateWebHookEventArgsForCall []struct {
		arg1 *http.Request
	}
	validateWebHookEventReturns struct {
		result1 interface{}
		result2 error
	}
	validateWebHookEventReturnsOnCall map[int]struct {
		result1 interface{}
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeInstallationClient) AddInstallation(arg1 string, arg2 int64) error {
	fake.addInstallationMutex.Lock()
	ret, specificReturn := fake.addInstallationReturnsOnCall[len(fake.addInstallationArgsForCall)]
	fake.addInstallationArgsForCall = append(fake.addInstallationArgsForCall, struct {
		arg1 string
		arg2 int64
	}{arg1, arg2})
	stub := fake.AddInstallationStub
	fakeReturns := fake.addInstallationReturns
	fake.recordInvocation("AddInstallation", []interface{}{arg1, arg2})
	fake.addInstallationMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeInstallationClient) AddInstallationCallCount() int {
	fake.addInstallationMutex.RLock()
	defer fake.addInstallationMutex.RUnlock()
	return len(fake.addInstallationArgsForCall)
}

func (fake *FakeInstallationClient) AddInstallationCalls(stub func(string, int64) error) {
	fake.addInstallationMutex.Lock()
	defer fake.addInstallationMutex.Unlock()
	fake.AddInstallationStub = stub
}

func (fake *FakeInstallationClient) AddInstallationArgsForCall(i int) (string, int64) {
	fake.addInstallationMutex.RLock()
	defer fake.addInstallationMutex.RUnlock()
	argsForCall := fake.addInstallationArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeInstallationClient) AddInstallationReturns(result1 error) {
	fake.addInstallationMutex.Lock()
	defer fake.addInstallationMutex.Unlock()
	fake.AddInstallationStub = nil
	fake.addInstallationReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeInstallationClient) AddInstallationReturnsOnCall(i int, result1 error) {
	fake.addInstallationMutex.Lock()
	defer fake.addInstallationMutex.Unlock()
	fake.AddInstallationStub = nil
	if fake.addInstallationReturnsOnCall == nil {
		fake.addInstallationReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.addInstallationReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeInstallationClient) CheckInstallation(arg1 string) bool {
	fake.checkInstallationMutex.Lock()
	ret, specificReturn := fake.checkInstallationReturnsOnCall[len(fake.checkInstallationArgsForCall)]
	fake.checkInstallationArgsForCall = append(fake.checkInstallationArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.CheckInstallationStub
	fakeReturns := fake.checkInstallationReturns
	fake.recordInvocation("CheckInstallation", []interface{}{arg1})
	fake.checkInstallationMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeInstallationClient) CheckInstallationCallCount() int {
	fake.checkInstallationMutex.RLock()
	defer fake.checkInstallationMutex.RUnlock()
	return len(fake.checkInstallationArgsForCall)
}

func (fake *FakeInstallationClient) CheckInstallationCalls(stub func(string) bool) {
	fake.checkInstallationMutex.Lock()
	defer fake.checkInstallationMutex.Unlock()
	fake.CheckInstallationStub = stub
}

func (fake *FakeInstallationClient) CheckInstallationArgsForCall(i int) string {
	fake.checkInstallationMutex.RLock()
	defer fake.checkInstallationMutex.RUnlock()
	argsForCall := fake.checkInstallationArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeInstallationClient) CheckInstallationReturns(result1 bool) {
	fake.checkInstallationMutex.Lock()
	defer fake.checkInstallationMutex.Unlock()
	fake.CheckInstallationStub = nil
	fake.checkInstallationReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeInstallationClient) CheckInstallationReturnsOnCall(i int, result1 bool) {
	fake.checkInstallationMutex.Lock()
	defer fake.checkInstallationMutex.Unlock()
	fake.CheckInstallationStub = nil
	if fake.checkInstallationReturnsOnCall == nil {
		fake.checkInstallationReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.checkInstallationReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeInstallationClient) DeleteComment(arg1 context.Context, arg2 string, arg3 string, arg4 int64) error {
	fake.deleteCommentMutex.Lock()
	ret, specificReturn := fake.deleteCommentReturnsOnCall[len(fake.deleteCommentArgsForCall)]
	fake.deleteCommentArgsForCall = append(fake.deleteCommentArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 int64
	}{arg1, arg2, arg3, arg4})
	stub := fake.DeleteCommentStub
	fakeReturns := fake.deleteCommentReturns
	fake.recordInvocation("DeleteComment", []interface{}{arg1, arg2, arg3, arg4})
	fake.deleteCommentMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeInstallationClient) DeleteCommentCallCount() int {
	fake.deleteCommentMutex.RLock()
	defer fake.deleteCommentMutex.RUnlock()
	return len(fake.deleteCommentArgsForCall)
}

func (fake *FakeInstallationClient) DeleteCommentCalls(stub func(context.Context, string, string, int64) error) {
	fake.deleteCommentMutex.Lock()
	defer fake.deleteCommentMutex.Unlock()
	fake.DeleteCommentStub = stub
}

func (fake *FakeInstallationClient) DeleteCommentArgsForCall(i int) (context.Context, string, string, int64) {
	fake.deleteCommentMutex.RLock()
	defer fake.deleteCommentMutex.RUnlock()
	argsForCall := fake.deleteCommentArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeInstallationClient) DeleteCommentReturns(result1 error) {
	fake.deleteCommentMutex.Lock()
	defer fake.deleteCommentMutex.Unlock()
	fake.DeleteCommentStub = nil
	fake.deleteCommentReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeInstallationClient) DeleteCommentReturnsOnCall(i int, result1 error) {
	fake.deleteCommentMutex.Lock()
	defer fake.deleteCommentMutex.Unlock()
	fake.DeleteCommentStub = nil
	if fake.deleteCommentReturnsOnCall == nil {
		fake.deleteCommentReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteCommentReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeInstallationClient) EnrichIssue(arg1 context.Context, arg2 string, arg3 string, arg4 model.Issue) model.EnrichedIssue {
	fake.enrichIssueMutex.Lock()
	ret, specificReturn := fake.enrichIssueReturnsOnCall[len(fake.enrichIssueArgsForCall)]
	fake.enrichIssueArgsForCall = append(fake.enrichIssueArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 model.Issue
	}{arg1, arg2, arg3, arg4})
	stub := fake.EnrichIssueStub
	fakeReturns := fake.enrichIssueReturns
	fake.recordInvocation("EnrichIssue", []interface{}{arg1, arg2, arg3, arg4})
	fake.enrichIssueMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeInstallationClient) EnrichIssueCallCount() int {
	fake.enrichIssueMutex.RLock()
	defer fake.enrichIssueMutex.RUnlock()
	return len(fake.enrichIssueArgsForCall)
}

func (fake *FakeInstallationClient) EnrichIssueCalls(stub func(context.Context, string, string, model.Issue) model.EnrichedIssue) {
	fake.enrichIssueMutex.Lock()
	defer fake.enrichIssueMutex.Unlock()
	fake.EnrichIssueStub = stub
}

func (fake *FakeInstallationClient) EnrichIssueArgsForCall(i int) (context.Context, string, string, model.Issue) {
	fake.enrichIssueMutex.RLock()
	defer fake.enrichIssueMutex.RUnlock()
	argsForCall := fake.enrichIssueArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeInstallationClient) EnrichIssueReturns(result1 model.EnrichedIssue) {
	fake.enrichIssueMutex.Lock()
	defer fake.enrichIssueMutex.Unlock()
	fake.EnrichIssueStub = nil
	fake.enrichIssueReturns = struct {
		result1 model.EnrichedIssue
	}{result1}
}

func (fake *FakeInstallationClient) EnrichIssueReturnsOnCall(i int, result1 model.EnrichedIssue) {
	fake.enrichIssueMutex.Lock()
	defer fake.enrichIssueMutex.Unlock()
	fake.EnrichIssueStub = nil
	if fake.enrichIssueReturnsOnCall == nil {
		fake.enrichIssueReturnsOnCall = make(map[int]struct {
			result1 model.EnrichedIssue
		})
	}
	fake.enrichIssueReturnsOnCall[i] = struct {
		result1 model.EnrichedIssue
	}{result1}
}

func (fake *FakeInstallationClient) EnrichIssues(arg1 context.Context, arg2 string, arg3 string, arg4 []model.Issue) map[int]model.EnrichedIssue {
	var arg4Copy []model.Issue
	if arg4 != nil {
		arg4Copy = make([]model.Issue, len(arg4))
		copy(arg4Copy, arg4)
	}
	fake.enrichIssuesMutex.Lock()
	ret, specificReturn := fake.enrichIssuesReturnsOnCall[len(fake.enrichIssuesArgsForCall)]
	fake.enrichIssuesArgsForCall = append(fake.enrichIssuesArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 []model.Issue
	}{arg1, arg2, arg3, arg4Copy})
	stub := fake.EnrichIssuesStub
	fakeReturns := fake.enrichIssuesReturns
	fake.recordInvocation("EnrichIssues", []interface{}{arg1, arg2, arg3, arg4Copy})
	fake.enrichIssuesMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeInstallationClient) EnrichIssuesCallCount() int {
	fake.enrichIssuesMutex.RLock()
	defer fake.enrichIssuesMutex.RUnlock()
	return len(fake.enrichIssuesArgsForCall)
}

func (fake *FakeInstallationClient) EnrichIssuesCalls(stub func(context.Context, string, string, []model.Issue) map[int]model.EnrichedIssue) {
	fake.enrichIssuesMutex.Lock()
	defer fake.enrichIssuesMutex.Unlock()
	fake.EnrichIssuesStub = stub
}

func (fake *FakeInstallationClient) EnrichIssuesArgsForCall(i int) (context.Context, string, string, []model.Issue) {
	fake.enrichIssuesMutex.RLock()
	defer fake.enrichIssuesMutex.RUnlock()
	argsForCall := fake.enrichIssuesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeInstallationClient) EnrichIssuesReturns(result1 map[int]model.EnrichedIssue) {
	fake.enrichIssuesMutex.Lock()
	defer fake.enrichIssuesMutex.Unlock()
	fake.EnrichIssuesStub = nil
	fake.enrichIssuesReturns = struct {
		result1 map[int]model.EnrichedIssue
	}{result1}
}

func (fake *FakeInstallationClient) EnrichIssuesReturnsOnCall(i int, result1 map[int]model.EnrichedIssue) {
	fake.enrichIssuesMutex.Lock()
	defer fake.enrichIssuesMutex.Unlock()
	fake.EnrichIssuesStub = nil
	if fake.enrichIssuesReturnsOnCall == nil {
		fake.enrichIssuesReturnsOnCall = make(map[int]struct {
			result1 map[int]model.EnrichedIssue
		})
	}
	fake.enrichIssuesReturnsOnCall[i] = struct {
		result1 map[int]model.EnrichedIssue
	}{result1}
}

func (fake *FakeInstallationClient) GetComments(arg1 context.Context, arg2 string, arg3 string, arg4 int) ([]model.IssueComment, error) {
	fake.getCommentsMutex.Lock()
	ret, specificReturn := fake.getCommentsReturnsOnCall[len(fake.getCommentsArgsForCall)]
	fake.getCommentsArgsForCall = append(fake.getCommentsArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 int
	}{arg1, arg2, arg3, arg4})
	stub := fake.GetCommentsStub
	fakeReturns := fake.getCommentsReturns
	fake.recordInvocation("GetComments", []interface{}{arg1, arg2, arg3, arg4})
	fake.getCommentsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeInstallationClient) GetCommentsCallCount() int {
	fake.getCommentsMutex.RLock()
	defer fake.getCommentsMutex.RUnlock()
	return len(fake.getCommentsArgsForCall)
}

func (fake *FakeInstallationClient) GetCommentsCalls(stub func(context.Context, string, string, int) ([]model.IssueComment, error)) {
	fake.getCommentsMutex.Lock()
	defer fake.getCommentsMutex.Unlock()
	fake.GetCommentsStub = stub
}

func (fake *FakeInstallationClient) GetCommentsArgsForCall(i int) (context.Context, string, string, int) {
	fake.getCommentsMutex.RLock()
	defer fake.getCommentsMutex.RUnlock()
	argsForCall := fake.getCommentsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeInstallationClient) GetCommentsReturns(result1 []model.IssueComment, result2 error) {
	fake.getCommentsMutex.Lock()
	defer fake.getCommentsMutex.Unlock()
	fake.GetCommentsStub = nil
	fake.getCommentsReturns = struct {
		result1 []model.IssueComment
		result2 error
	}{result1, result2}
}

func (fake *FakeInstallationClient) GetCommentsReturnsOnCall(i int, result1 []model.IssueComment, result2 error) {
	fake.getCommentsMutex.Lock()
	defer fake.getCommentsMutex.Unlock()
	fake.GetCommentsStub = nil
	if fake.getCommentsReturnsOnCall == nil {
		fake.getCommentsReturnsOnCall = make(map[int]struct {
			result1 []model.IssueComment
			result2 error
		})
	}
	fake.getCommentsReturnsOnCall[i] = struct {
		result1 []model.IssueComment
		result2 error
	}{result1, result2}
}

func (fake *FakeInstallationClient) GetEnrichedIssues(arg1 context.Context, arg2 string, arg3 string, arg4 model.IssueState) (map[int]model.EnrichedIssue, error) {
	fake.getEnrichedIssuesMutex.Lock()
	ret, specificReturn := fake.getEnrichedIssuesReturnsOnCall[len(fake.getEnrichedIssuesArgsForCall)]
	fake.getEnrichedIssuesArgsForCall = append(fake.getEnrichedIssuesArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 model.IssueState
	}{arg1, arg2, arg3, arg4})
	stub := fake.GetEnrichedIssuesStub
	fakeReturns := fake.getEnrichedIssuesReturns
	fake.recordInvocation("GetEnrichedIssues", []interface{}{arg1, arg2, arg3, arg4})
	fake.getEnrichedIssuesMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeInstallationClient) GetEnrichedIssuesCallCount() int {
	fake.getEnrichedIssuesMutex.RLock()
	defer fake.getEnrichedIssuesMutex.RUnlock()
	return len(fake.getEnrichedIssuesArgsForCall)
}

func (fake *FakeInstallationClient) GetEnrichedIssuesCalls(stub func(context.Context, string, string, model.IssueState) (map[int]model.EnrichedIssue, error)) {
	fake.getEnrichedIssuesMutex.Lock()
	defer fake.getEnrichedIssuesMutex.Unlock()
	fake.GetEnrichedIssuesStub = stub
}

func (fake *FakeInstallationClient) GetEnrichedIssuesArgsForCall(i int) (context.Context, string, string, model.IssueState) {
	fake.getEnrichedIssuesMutex.RLock()
	defer fake.getEnrichedIssuesMutex.RUnlock()
	argsForCall := fake.getEnrichedIssuesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeInstallationClient) GetEnrichedIssuesReturns(result1 map[int]model.EnrichedIssue, result2 error) {
	fake.getEnrichedIssuesMutex.Lock()
	defer fake.getEnrichedIssuesMutex.Unlock()
	fake.GetEnrichedIssuesStub = nil
	fake.getEnrichedIssuesReturns = struct {
		result1 map[int]model.EnrichedIssue
		result2 error
	}{result1, result2}
}

func (fake *FakeInstallationClient) GetEnrichedIssuesReturnsOnCall(i int, result1 map[int]model.EnrichedIssue, result2 error) {
	fake.getEnrichedIssuesMutex.Lock()
	defer fake.getEnrichedIssuesMutex.Unlock()
	fake.GetEnrichedIssuesStub = nil
	if fake.getEnrichedIssuesReturnsOnCall == nil {
		fake.getEnrichedIssuesReturnsOnCall = make(map[int]struct {
			result1 map[int]model.EnrichedIssue
			result2 error
		})
	}
	fake.getEnrichedIssuesReturnsOnCall[i] = struct {
		result1 map[int]model.EnrichedIssue
		result2 error
	}{result1, result2}
}

func (fake *FakeInstallationClient) GetIssueEvents(arg1 context.Context, arg2 string, arg3 string, arg4 int) ([]model.IssueEvent, error) {
	fake.getIssueEventsMutex.Lock()
	ret, specificReturn := fake.getIssueEventsReturnsOnCall[len(fake.getIssueEventsArgsForCall)]
	fake.getIssueEventsArgsForCall = append(fake.getIssueEventsArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 int
	}{arg1, arg2, arg3, arg4})
	stub := fake.GetIssueEventsStub
	fakeReturns := fake.getIssueEventsReturns
	fake.recordInvocation("GetIssueEvents", []interface{}{arg1, arg2, arg3, arg4})
	fake.getIssueEventsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeInstallationClient) GetIssueEventsCallCount() int {
	fake.getIssueEventsMutex.RLock()
	defer fake.getIssueEventsMutex.RUnlock()
	return len(fake.getIssueEventsArgsForCall)
}

func (fake *FakeInstallationClient) GetIssueEventsCalls(stub func(context.Context, string, string, int) ([]model.IssueEvent, error)) {
	fake.getIssueEventsMutex.Lock()
	defer fake.getIssueEventsMutex.Unlock()
	fake.GetIssueEventsStub = stub
}

func (fake *FakeInstallationClient) GetIssueEventsArgsForCall(i int) (context.Context, string, string, int) {
	fake.getIssueEventsMutex.RLock()
	defer fake.getIssueEventsMutex.RUnlock()
	argsForCall := fake.getIssueEventsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeInstallationClient) GetIssueEventsReturns(result1 []model.IssueEvent, result2 error) {
	fake.getIssueEventsMutex.Lock()
	defer fake.getIssueEventsMutex.Unlock()
	fake.GetIssueEventsStub = nil
	fake.getIssueEventsReturns = struct {
		result1 []model.IssueEvent
		result2 error
	}{result1, result2}
}

func (fake *FakeInstallationClient) GetIssueEventsReturnsOnCall(i int, result1 []model.IssueEvent, result2 error) {
	fake.getIssueEventsMutex.Lock()
	defer fake.getIssueEventsMutex.Unlock()
	fake.GetIssueEventsStub = nil
	if fake.getIssueEventsReturnsOnCall == nil {
		fake.getIssueEventsReturnsOnCall = make(map[int]struct {
			result1 []model.IssueEvent
			result2 error
		})
	}
	fake.getIssueEventsReturnsOnCall[i] = struct {
		result1 []model.IssueEvent
		result2 error
	}{result1, result2}
}

func (fake *FakeInstallationClient) GetIssuePullRequest(arg1 context.Context, arg2 string, arg3 string, arg4 int) (*string, error) {
	fake.getIssuePullRequestMutex.Lock()
	ret, specificReturn := fake.getIssuePullRequestReturnsOnCall[len(fake.getIssuePullRequestArgsForCall)]
	fake.getIssuePullRequestArgsForCall = append(fake.getIssuePullRequestArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 int
	}{arg1, arg2, arg3, arg4})
	stub := fake.GetIssuePullRequestStub
	fakeReturns := fake.getIssuePullRequestReturns
	fake.recordInvocation("GetIssuePullRequest", []interface{}{arg1, arg2, arg3, arg4})
	fake.getIssuePullRequestMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeInstallationClient) GetIssuePullRequestCallCount() int {
	fake.getIssuePullRequestMutex.RLock()
	defer fake.getIssuePullRequestMutex.RUnlock()
	return len(fake.getIssuePullRequestArgsForCall)
}

func (fake *FakeInstallationClient) GetIssuePullRequestCalls(stub func(context.Context, string, string, int) (*string, error)) {
	fake.getIssuePullRequestMutex.Lock()
	defer fake.getIssuePullRequestMutex.Unlock()
	fake.GetIssuePullRequestStub = stub
}

func (fake *FakeInstallationClient) GetIssuePullRequestArgsForCall(i int) (context.Context, string, string, int) {
	fake.getIssuePullRequestMutex.RLock()
	defer fake.getIssuePullRequestMutex.RUnlock()
	argsForCall := fake.getIssuePullRequestArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeInstallationClient) GetIssuePullRequestReturns(result1 *string, result2 error) {
	fake.getIssuePullRequestMutex.Lock()
	defer fake.getIssuePullRequestMutex.Unlock()
	fake.GetIssuePullRequestStub = nil
	fake.getIssuePullRequestReturns = struct {
		result1 *string
		result2 error
	}{result1, result2}
}

func (fake *FakeInstallationClient) GetIssuePullRequestReturnsOnCall(i int, result1 *string, result2 error) {
	fake.getIssuePullRequestMutex.Lock()
	defer fake.getIssuePullRequestMutex.Unlock()
	fake.GetIssuePullRequestStub = nil
	if fake.getIssuePullRequestReturnsOnCall == nil {
		fake.getIssuePullRequestReturnsOnCall = make(map[int]struct {
			result1 *string
			result2 error
		})
	}
	fake.getIssuePullRequestReturnsOnCall[i] = struct {
		result1 *string
		result2 error
	}{result1, result2}
}

func (fake *FakeInstallationClient) GetIssuesByRepo(arg1 context.Context, arg2 string, arg3 string, arg4 []string, arg5 *model.IssueState) ([]model.Issue, error) {
	var arg4Copy []string
	if arg4 != nil {
		arg4Copy = make([]string, len(arg4))
		copy(arg4Copy, arg4)
	}
	fake.getIssuesByRepoMutex.Lock()
	ret, specificReturn := fake.getIssuesByRepoReturnsOnCall[len(fake.getIssuesByRepoArgsForCall)]
	fake.getIssuesByRepoArgsForCall = append(fake.getIssuesByRepoArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 []string
		arg5 *model.IssueState
	}{arg1, arg2, arg3, arg4Copy, arg5})
	stub := fake.GetIssuesByRepoStub
	fakeReturns := fake.getIssuesByRepoReturns
	fake.recordInvocation("GetIssuesByRepo", []interface{}{arg1, arg2, arg3, arg4Copy, arg5})
	fake.getIssuesByRepoMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeInstallationClient) GetIssuesByRepoCallCount() int {
	fake.getIssuesByRepoMutex.RLock()
	defer fake.getIssuesByRepoMutex.RUnlock()
	return len(fake.getIssuesByRepoArgsForCall)
}

func (fake *FakeInstallationClient) GetIssuesByRepoCalls(stub func(context.Context, string, string, []string, *model.IssueState) ([]model.Issue, error)) {
	fake.getIssuesByRepoMutex.Lock()
	defer fake.getIssuesByRepoMutex.Unlock()
	fake.GetIssuesByRepoStub = stub
}

func (fake *FakeInstallationClient) GetIssuesByRepoArgsForCall(i int) (context.Context, string, string, []string, *model.IssueState) {
	fake.getIssuesByRepoMutex.RLock()
	defer fake.getIssuesByRepoMutex.RUnlock()
	argsForCall := fake.getIssuesByRepoArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeInstallationClient) GetIssuesByRepoReturns(result1 []model.Issue, result2 error) {
	fake.getIssuesByRepoMutex.Lock()
	defer fake.getIssuesByRepoMutex.Unlock()
	fake.GetIssuesByRepoStub = nil
	fake.getIssuesByRepoReturns = struct {
		result1 []model.Issue
		result2 error
	}{result1, result2}
}

func (fake *FakeInstallationClient) GetIssuesByRepoReturnsOnCall(i int, result1 []model.Issue, result2 error) {
	fake.getIssuesByRepoMutex.Lock()
	defer fake.getIssuesByRepoMutex.Unlock()
	fake.GetIssuesByRepoStub = nil
	if fake.getIssuesByRepoReturnsOnCall == nil {
		fake.getIssuesByRepoReturnsOnCall = make(map[int]struct {
			result1 []model.Issue
			result2 error
		})
	}
	fake.getIssuesByRepoReturnsOnCall[i] = struct {
		result1 []model.Issue
		result2 error
	}{result1, result2}
}

func (fake *FakeInstallationClient) GetRateLimit(arg1 context.Context, arg2 string) (model.RateLimit, error) {
	fake.getRateLimitMutex.Lock()
	ret, specificReturn := fake.getRateLimitReturnsOnCall[len(fake.getRateLimitArgsForCall)]
	fake.getRateLimitArgsForCall = append(fake.getRateLimitArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.GetRateLimitStub
	fakeReturns := fake.getRateLimitReturns
	fake.recordInvocation("GetRateLimit", []interface{}{arg1, arg2})
	fake.getRateLimitMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeInstallationClient) GetRateLimitCallCount() int {
	fake.getRateLimitMutex.RLock()
	defer fake.getRateLimitMutex.RUnlock()
	return len(fake.getRateLimitArgsForCall)
}

func (fake *FakeInstallationClient) GetRateLimitCalls(stub func(context.Context, string) (model.RateLimit, error)) {
	fake.getRateLimitMutex.Lock()
	defer fake.getRateLimitMutex.Unlock()
	fake.GetRateLimitStub = stub
}

func (fake *FakeInstallationClient) GetRateLimitArgsForCall(i int) (context.Context, string) {
	fake.getRateLimitMutex.RLock()
	defer fake.getRateLimitMutex.RUnlock()
	argsForCall := fake.getRateLimitArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeInstallationClient) GetRateLimitReturns(result1 model.RateLimit, result2 error) {
	fake.getRateLimitMutex.Lock()
	defer fake.getRateLimitMutex.Unlock()
	fake.GetRateLimitStub = nil
	fake.getRateLimitReturns = struct {
		result1 model.RateLimit
		result2 error
	}{result1, result2}
}

func (fake *FakeInstallationClient) GetRateLimitReturnsOnCall(i int, result1 model.RateLimit, result2 error) {
	fake.getRateLimitMutex.Lock()
	defer fake.getRateLimitMutex.Unlock()
	fake.GetRateLimitStub = nil
	if fake.getRateLimitReturnsOnCall == nil {
		fake.getRateLimitReturnsOnCall = make(map[int]struct {
			result1 model.RateLimit
			result2 error
		})
	}
	fake.getRateLimitReturnsOnCall[i] = struct {
		result1 model.RateLimit
		result2 error
	}{result1, result2}
}

func (fake *FakeInstallationClient) GetRepos(arg1 context.Context, arg2 string) ([]string, error) {
	fake.getReposMutex.Lock()
	ret, specificReturn := fake.getReposReturnsOnCall[len(fake.getReposArgsForCall)]
	fake.getReposArgsForCall = append(fake.getReposArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.GetReposStub
	fakeReturns := fake.getReposReturns
	fake.recordInvocation("GetRepos", []interface{}{arg1, arg2})
	fake.getReposMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeInstallationClient) GetReposCallCount() int {
	fake.getReposMutex.RLock()
	defer fake.getReposMutex.RUnlock()
	return len(fake.getReposArgsForCall)
}

func (fake *FakeInstallationClient) GetReposCalls(stub func(context.Context, string) ([]string, error)) {
	fake.getReposMutex.Lock()
	defer fake.getReposMutex.Unlock()
	fake.GetReposStub = stub
}

func (fake *FakeInstallationClient) GetReposArgsForCall(i int) (context.Context, string) {
	fake.getReposMutex.RLock()
	defer fake.getReposMutex.RUnlock()
	argsForCall := fake.getReposArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeInstallationClient) GetReposReturns(result1 []string, result2 error) {
	fake.getReposMutex.Lock()
	defer fake.getReposMutex.Unlock()
	fake.GetReposStub = nil
	fake.getReposReturns = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeInstallationClient) GetReposReturnsOnCall(i int, result1 []string, result2 error) {
	fake.getReposMutex.Lock()
	defer fake.getReposMutex.Unlock()
	fake.GetReposStub = nil
	if fake.getReposReturnsOnCall == nil {
		fake.getReposReturnsOnCall = make(map[int]struct {
			result1 []string
			result2 error
		})
	}
	fake.getReposReturnsOnCall[i] = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeInstallationClient) GetUser(arg1 context.Context, arg2 string, arg3 string) (model.User, error) {
	fake.getUserMutex.Lock()
	ret, specificReturn := fake.getUserReturnsOnCall[len(fake.getUserArgsForCall)]
	fake.getUserArgsForCall = append(fake.getUserArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.GetUserStub
	fakeReturns := fake.getUserReturns
	fake.recordInvocation("GetUser", []interface{}{arg1, arg2, arg3})
	fake.getUserMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeInstallationClient) GetUserCallCount() int {
	fake.getUserMutex.RLock()
	defer fake.getUserMutex.RUnlock()
	return len(fake.getUserArgsForCall)
}

func (fake *FakeInstallationClient) GetUserCalls(stub func(context.Context, string, string) (model.User, error)) {
	fake.getUserMutex.Lock()
	defer fake.getUserMutex.Unlock()
	fake.GetUserStub = stub
}

func (fake *FakeInstallationClient) GetUserArgsForCall(i int) (context.Context, string, string) {
	fake.getUserMutex.RLock()
	defer fake.getUserMutex.RUnlock()
	argsForCall := fake.getUserArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeInstallationClient) GetUserReturns(result1 model.User, result2 error) {
	fake.getUserMutex.Lock()
	defer fake.getUserMutex.Unlock()
	fake.GetUserStub = nil
	fake.getUserReturns = struct {
		result1 model.User
		result2 error
	}{result1, result2}
}

func (fake *FakeInstallationClient) GetUserReturnsOnCall(i int, result1 model.User, result2 error) {
	fake.getUserMutex.Lock()
	defer fake.getUserMutex.Unlock()
	fake.GetUserStub = nil
	if fake.getUserReturnsOnCall == nil {
		fake.getUserReturnsOnCall = make(map[int]struct {
			result1 model.User
			result2 error
		})
	}
	fake.getUserReturnsOnCall[i] = struct {
		result1 model.User
		result2 error
	}{result1, result2}
}

func (fake *FakeInstallationClient) PostComment(arg1 context.Context, arg2 string, arg3 string, arg4 int, arg5 string) error {
	fake.postCommentMutex.Lock()
	ret, specificReturn := fake.postCommentReturnsOnCall[len(fake.postCommentArgsForCall)]
	fake.postCommentArgsForCall = append(fake.postCommentArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 int
		arg5 string
	}{arg1, arg2, arg3, arg4, arg5})
	stub := fake.PostCommentStub
	fakeReturns := fake.postCommentReturns
	fake.recordInvocation("PostComment", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.postCommentMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeInstallationClient) PostCommentCallCount() int {
	fake.postCommentMutex.RLock()
	defer fake.postCommentMutex.RUnlock()
	return len(fake.postCommentArgsForCall)
}

func (fake *FakeInstallationClient) PostCommentCalls(stub func(context.Context, string, string, int, string) error) {
	fake.postCommentMutex.Lock()
	defer fake.postCommentMutex.Unlock()
	fake.PostCommentStub = stub
}

func (fake *FakeInstallationClient) PostCommentArgsForCall(i int) (context.Context, string, string, int, string) {
	fake.postCommentMutex.RLock()
	defer fake.postCommentMutex.RUnlock()
	argsForCall := fake.postCommentArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeInstallationClient) PostCommentReturns(result1 error) {
	fake.postCommentMutex.Lock()
	defer fake.postCommentMutex.Unlock()
	fake.PostCommentStub = nil
	fake.postCommentReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeInstallationClient) PostCommentReturnsOnCall(i int, result1 error) {
	fake.postCommentMutex.Lock()
	defer fake.postCommentMutex.Unlock()
	fake.PostCommentStub = nil
	if fake.postCommentReturnsOnCall == nil {
		fake.postCommentReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.postCommentReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeInstallationClient) PostLabel(arg1 context.Context, arg2 string, arg3 string, arg4 model.Label) error {
	fake.postLabelMutex.Lock()
	ret, specificReturn := fake.postLabelReturnsOnCall[len(fake.postLabelArgsForCall)]
	fake.postLabelArgsForCall = append(fake.postLabelArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 model.Label
	}{arg1, arg2, arg3, arg4})
	stub := fake.PostLabelStub
	fakeReturns := fake.postLabelReturns
	fake.recordInvocation("PostLabel", []interface{}{arg1, arg2, arg3, arg4})
	fake.postLabelMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeInstallationClient) PostLabelCallCount() int {
	fake.postLabelMutex.RLock()
	defer fake.postLabelMutex.RUnlock()
	return len(fake.postLabelArgsForCall)
}

func (fake *FakeInstallationClient) PostLabelCalls(stub func(context.Context, string, string, model.Label) error) {
	fake.postLabelMutex.Lock()
	defer fake.postLabelMutex.Unlock()
	fake.PostLabelStub = stub
}

func (fake *FakeInstallationClient) PostLabelArgsForCall(i int) (context.Context, string, string, model.Label) {
	fake.postLabelMutex.RLock()
	defer fake.postLabelMutex.RUnlock()
	argsForCall := fake.postLabelArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeInstallationClient) PostLabelReturns(result1 error) {
	fake.postLabelMutex.Lock()
	defer fake.postLabelMutex.Unlock()
	fake.PostLabelStub = nil
	fake.postLabelReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeInstallationClient) PostLabelReturnsOnCall(i int, result1 error) {
	fake.postLabelMutex.Lock()
	defer fake.postLabelMutex.Unlock()
	fake.PostLabelStub = nil
	if fake.postLabelReturnsOnCall == nil {
		fake.postLabelReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.postLabelReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeInstallationClient) PostLabels(arg1 context.Context, arg2 string, arg3 []string, arg4 map[string]model.Label) []error {
	var arg3Copy []string
	if arg3 != nil {
		arg3Copy = make([]string, len(arg3))
		copy(arg3Copy, arg3)
	}
	fake.postLabelsMutex.Lock()
	ret, specificReturn := fake.postLabelsReturnsOnCall[len(fake.postLabelsArgsForCall)]
	fake.postLabelsArgsForCall = append(fake.postLabelsArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 []string
		arg4 map[string]model.Label
	}{arg1, arg2, arg3Copy, arg4})
	stub := fake.PostLabelsStub
	fakeReturns := fake.postLabelsReturns
	fake.recordInvocation("PostLabels", []interface{}{arg1, arg2, arg3Copy, arg4})
	fake.postLabelsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeInstallationClient) PostLabelsCallCount() int {
	fake.postLabelsMutex.RLock()
	defer fake.postLabelsMutex.RUnlock()
	return len(fake.postLabelsArgsForCall)
}

func (fake *FakeInstallationClient) PostLabelsCalls(stub func(context.Context, string, []string, map[string]model.Label) []error) {
	fake.postLabelsMutex.Lock()
	defer fake.postLabelsMutex.Unlock()
	fake.PostLabelsStub = stub
}

func (fake *FakeInstallationClient) PostLabelsArgsForCall(i int) (context.Context, string, []string, map[string]model.Label) {
	fake.postLabelsMutex.RLock()
	defer fake.postLabelsMutex.RUnlock()
	argsForCall := fake.postLabelsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeInstallationClient) PostLabelsReturns(result1 []error) {
	fake.postLabelsMutex.Lock()
	defer fake.postLabelsMutex.Unlock()
	fake.PostLabelsStub = nil
	fake.postLabelsReturns = struct {
		result1 []error
	}{result1}
}

func (fake *FakeInstallationClient) PostLabelsReturnsOnCall(i int, result1 []error) {
	fake.postLabelsMutex.Lock()
	defer fake.postLabelsMutex.Unlock()
	fake.PostLabelsStub = nil
	if fake.postLabelsReturnsOnCall == nil {
		fake.postLabelsReturnsOnCall = make(map[int]struct {
			result1 []error
		})
	}
	fake.postLabelsReturnsOnCall[i] = struct {
		result1 []error
	}{result1}
}

func (fake *FakeInstallationClient) UpdateComment(arg1 context.Context, arg2 string, arg3 string, arg4 int64, arg5 string) error {
	fake.updateCommentMutex.Lock()
	ret, specificReturn := fake.updateCommentReturnsOnCall[len(fake.updateCommentArgsForCall)]
	fake.updateCommentArgsForCall = append(fake.updateCommentArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 int64
		arg5 string
	}{arg1, arg2, arg3, arg4, arg5})
	stub := fake.UpdateCommentStub
	fakeReturns := fake.updateCommentReturns
	fake.recordInvocation("UpdateComment", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.updateCommentMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeInstallationClient) UpdateCommentCallCount() int {
	fake.updateCommentMutex.RLock()
	defer fake.updateCommentMutex.RUnlock()
	return len(fake.updateCommentArgsForCall)
}

func (fake *FakeInstallationClient) UpdateCommentCalls(stub func(context.Context, string, string, int64, string) error) {
	fake.updateCommentMutex.Lock()
	defer fake.updateCommentMutex.Unlock()
	fake.UpdateCommentStub = stub
}

func (fake *FakeInstallationClient) UpdateCommentArgsForCall(i int) (context.Context, string, string, int64, string) {
	fake.updateCommentMutex.RLock()
	defer fake.updateCommentMutex.RUnlock()
	argsForCall := fake.updateCommentArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeInstallationClient) UpdateCommentReturns(result1 error) {
	fake.updateCommentMutex.Lock()
	defer fake.updateCommentMutex.Unlock()
	fake.UpdateCommentStub = nil
	fake.updateCommentReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeInstallationClient) UpdateCommentReturnsOnCall(i int, result1 error) {
	fake.updateCommentMutex.Lock()
	defer fake.updateCommentMutex.Unlock()
	fake.UpdateCommentStub = nil
	if fake.updateCommentReturnsOnCall == nil {
		fake.updateCommentReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.updateCommentReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeInstallationClient) ValidateWebHookEvent(arg1 *http.Request) (interface{}, error) {
	fake.validateWebHookEventMutex.Lock()
	ret, specificReturn := fake.validateWebHookEventReturnsOnCall[len(fake.validateWebHookEventArgsForCall)]
	fake.validateWebHookEventArgsForCall = append(fake.validateWebHookEventArgsForCall, struct {
		arg1 *http.Request
	}{arg1})
	stub := fake.ValidateWebHookEventStub
	fakeReturns := fake.validateWebHookEventReturns
	fake.recordInvocation("ValidateWebHookEvent", []interface{}{arg1})
	fake.validateWebHookEventMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeInstallationClient) ValidateWebHookEventCallCount() int {
	fake.validateWebHookEventMutex.RLock()
	defer fake.validateWebHookEventMutex.RUnlock()
	return len(fake.validateWebHookEventArgsForCall)
}

func (fake *FakeInstallationClient) ValidateWebHookEventCalls(stub func(*http.Request) (interface{}, error)) {
	fake.validateWebHookEventMutex.Lock()
	defer fake.validateWebHookEventMutex.Unlock()
	fake.ValidateWebHookEventStub = stub
}

func (fake *FakeInstallationClient) ValidateWebHookEventArgsForCall(i int) *http.Request {
	fake.validateWebHookEventMutex.RLock()
	defer fake.validateWebHookEventMutex.RUnlock()
	argsForCall := fake.validateWebHookEventArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeInstallationClient) ValidateWebHookEventReturns(result1 interface{}, result2 error) {
	fake.validateWebHookEventMutex.Lock()
	defer fake.validateWebHookEventMutex.Unlock()
	fake.ValidateWebHookEventStub = nil
	fake.validateWebHookEventReturns = struct {
		result1 interface{}
		result2 error
	}{result1, result2}
}

func (fake *FakeInstallationClient) ValidateWebHookEventReturnsOnCall(i int, result1 interface{}, result2 error) {
	fake.validateWebHookEventMutex.Lock()
	defer fake.validateWebHookEventMutex.Unlock()
	fake.ValidateWebHookEventStub = nil
	if fake.validateWebHookEventReturnsOnCall == nil {
		fake.validateWebHookEventReturnsOnCall = make(map[int]struct {
			result1 interface{}
			result2 error
		})
	}
	fake.validateWebHookEventReturnsOnCall[i] = struct {
		result1 interface{}
		result2 error
	}{result1, result2}
}

func (fake *FakeInstallationClient) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.addInstallationMutex.RLock()
	defer fake.addInstallationMutex.RUnlock()
	fake.checkInstallationMutex.RLock()
	defer fake.checkInstallationMutex.RUnlock()
	fake.deleteCommentMutex.RLock()
	defer fake.deleteCommentMutex.RUnlock()
	fake.enrichIssueMutex.RLock()
	defer fake.enrichIssueMutex.RUnlock()
	fake.enrichIssuesMutex.RLock()
	defer fake.enrichIssuesMutex.RUnlock()
	fake.getCommentsMutex.RLock()
	defer fake.getCommentsMutex.RUnlock()
	fake.getEnrichedIssuesMutex.RLock()
	defer fake.getEnrichedIssuesMutex.RUnlock()
	fake.getIssueEventsMutex.RLock()
	defer fake.getIssueEventsMutex.RUnlock()
	fake.getIssuePullRequestMutex.RLock()
	defer fake.getIssuePullRequestMutex.RUnlock()
	fake.getIssuesByRepoMutex.RLock()
	defer fake.getIssuesByRepoMutex.RUnlock()
	fake.getRateLimitMutex.RLock()
	defer fake.getRateLimitMutex.RUnlock()
	fake.getReposMutex.RLock()
	defer fake.getReposMutex.RUnlock()
	fake.getUserMutex.RLock()
	defer fake.getUserMutex.RUnlock()
	fake.postCommentMutex.RLock()
	defer fake.postCommentMutex.RUnlock()
	fake.postLabelMutex.RLock()
	defer fake.postLabelMutex.RUnlock()
	fake.postLabelsMutex.RLock()
	defer fake.postLabelsMutex.RUnlock()
	fake.updateCommentMutex.RLock()
	defer fake.updateCommentMutex.RUnlock()
	fake.validateWebHookEventMutex.RLock()
	defer fake.validateWebHookEventMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeInstallationClient) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ providers.InstallationClient = new(FakeInstallationClient)
