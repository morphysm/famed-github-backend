// Code generated by counterfeiter. DO NOT EDIT.
package githubfakes

import (
	"context"
	"net/http"
	"sync"

	"github.com/morphysm/famed-github-backend/internal/client/github"
)

type FakeInstallationClient struct {
	AddInstallationStub        func(string, int64) error
	addInstallationMutex       sync.RWMutex
	addInstallationArgsForCall []struct {
		arg1 string
		arg2 int64
	}
	addInstallationReturns struct {
		result1 error
	}
	addInstallationReturnsOnCall map[int]struct {
		result1 error
	}
	CheckInstallationStub        func(string) bool
	checkInstallationMutex       sync.RWMutex
	checkInstallationArgsForCall []struct {
		arg1 string
	}
	checkInstallationReturns struct {
		result1 bool
	}
	checkInstallationReturnsOnCall map[int]struct {
		result1 bool
	}
	GetCommentsStub        func(context.Context, string, string, int) ([]github.IssueComment, error)
	getCommentsMutex       sync.RWMutex
	getCommentsArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 int
	}
	getCommentsReturns struct {
		result1 []github.IssueComment
		result2 error
	}
	getCommentsReturnsOnCall map[int]struct {
		result1 []github.IssueComment
		result2 error
	}
	GetIssueEventsStub        func(context.Context, string, string, int) ([]github.IssueEvent, error)
	getIssueEventsMutex       sync.RWMutex
	getIssueEventsArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 int
	}
	getIssueEventsReturns struct {
		result1 []github.IssueEvent
		result2 error
	}
	getIssueEventsReturnsOnCall map[int]struct {
		result1 []github.IssueEvent
		result2 error
	}
	GetIssuePullRequestStub        func(context.Context, string, string, int) (*github.PullRequest, error)
	getIssuePullRequestMutex       sync.RWMutex
	getIssuePullRequestArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 int
	}
	getIssuePullRequestReturns struct {
		result1 *github.PullRequest
		result2 error
	}
	getIssuePullRequestReturnsOnCall map[int]struct {
		result1 *github.PullRequest
		result2 error
	}
	GetIssuesByRepoStub        func(context.Context, string, string, []string, *github.IssueState) ([]github.Issue, error)
	getIssuesByRepoMutex       sync.RWMutex
	getIssuesByRepoArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 []string
		arg5 *github.IssueState
	}
	getIssuesByRepoReturns struct {
		result1 []github.Issue
		result2 error
	}
	getIssuesByRepoReturnsOnCall map[int]struct {
		result1 []github.Issue
		result2 error
	}
	GetRateLimitStub        func(context.Context, string) (github.RateLimit, error)
	getRateLimitMutex       sync.RWMutex
	getRateLimitArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	getRateLimitReturns struct {
		result1 github.RateLimit
		result2 error
	}
	getRateLimitReturnsOnCall map[int]struct {
		result1 github.RateLimit
		result2 error
	}
	GetReposStub        func(context.Context, string) ([]github.Repo, error)
	getReposMutex       sync.RWMutex
	getReposArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	getReposReturns struct {
		result1 []github.Repo
		result2 error
	}
	getReposReturnsOnCall map[int]struct {
		result1 []github.Repo
		result2 error
	}
	GetUserStub        func(context.Context, string, string) (github.User, error)
	getUserMutex       sync.RWMutex
	getUserArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}
	getUserReturns struct {
		result1 github.User
		result2 error
	}
	getUserReturnsOnCall map[int]struct {
		result1 github.User
		result2 error
	}
	PostCommentStub        func(context.Context, string, string, int, string) error
	postCommentMutex       sync.RWMutex
	postCommentArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 int
		arg5 string
	}
	postCommentReturns struct {
		result1 error
	}
	postCommentReturnsOnCall map[int]struct {
		result1 error
	}
	PostLabelStub        func(context.Context, string, string, github.Label) error
	postLabelMutex       sync.RWMutex
	postLabelArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 github.Label
	}
	postLabelReturns struct {
		result1 error
	}
	postLabelReturnsOnCall map[int]struct {
		result1 error
	}
	PostLabelsStub        func(context.Context, string, []string, map[string]github.Label) []error
	postLabelsMutex       sync.RWMutex
	postLabelsArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 []string
		arg4 map[string]github.Label
	}
	postLabelsReturns struct {
		result1 []error
	}
	postLabelsReturnsOnCall map[int]struct {
		result1 []error
	}
	UpdateCommentStub        func(context.Context, string, string, int64, string) error
	updateCommentMutex       sync.RWMutex
	updateCommentArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 int64
		arg5 string
	}
	updateCommentReturns struct {
		result1 error
	}
	updateCommentReturnsOnCall map[int]struct {
		result1 error
	}
	ValidateWebHookEventStub        func(*http.Request) (interface{}, error)
	validateWebHookEventMutex       sync.RWMutex
	validateWebHookEventArgsForCall []struct {
		arg1 *http.Request
	}
	validateWebHookEventReturns struct {
		result1 interface{}
		result2 error
	}
	validateWebHookEventReturnsOnCall map[int]struct {
		result1 interface{}
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeInstallationClient) AddInstallation(arg1 string, arg2 int64) error {
	fake.addInstallationMutex.Lock()
	ret, specificReturn := fake.addInstallationReturnsOnCall[len(fake.addInstallationArgsForCall)]
	fake.addInstallationArgsForCall = append(fake.addInstallationArgsForCall, struct {
		arg1 string
		arg2 int64
	}{arg1, arg2})
	stub := fake.AddInstallationStub
	fakeReturns := fake.addInstallationReturns
	fake.recordInvocation("AddInstallation", []interface{}{arg1, arg2})
	fake.addInstallationMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeInstallationClient) AddInstallationCallCount() int {
	fake.addInstallationMutex.RLock()
	defer fake.addInstallationMutex.RUnlock()
	return len(fake.addInstallationArgsForCall)
}

func (fake *FakeInstallationClient) AddInstallationCalls(stub func(string, int64) error) {
	fake.addInstallationMutex.Lock()
	defer fake.addInstallationMutex.Unlock()
	fake.AddInstallationStub = stub
}

func (fake *FakeInstallationClient) AddInstallationArgsForCall(i int) (string, int64) {
	fake.addInstallationMutex.RLock()
	defer fake.addInstallationMutex.RUnlock()
	argsForCall := fake.addInstallationArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeInstallationClient) AddInstallationReturns(result1 error) {
	fake.addInstallationMutex.Lock()
	defer fake.addInstallationMutex.Unlock()
	fake.AddInstallationStub = nil
	fake.addInstallationReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeInstallationClient) AddInstallationReturnsOnCall(i int, result1 error) {
	fake.addInstallationMutex.Lock()
	defer fake.addInstallationMutex.Unlock()
	fake.AddInstallationStub = nil
	if fake.addInstallationReturnsOnCall == nil {
		fake.addInstallationReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.addInstallationReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeInstallationClient) CheckInstallation(arg1 string) bool {
	fake.checkInstallationMutex.Lock()
	ret, specificReturn := fake.checkInstallationReturnsOnCall[len(fake.checkInstallationArgsForCall)]
	fake.checkInstallationArgsForCall = append(fake.checkInstallationArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.CheckInstallationStub
	fakeReturns := fake.checkInstallationReturns
	fake.recordInvocation("CheckInstallation", []interface{}{arg1})
	fake.checkInstallationMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeInstallationClient) CheckInstallationCallCount() int {
	fake.checkInstallationMutex.RLock()
	defer fake.checkInstallationMutex.RUnlock()
	return len(fake.checkInstallationArgsForCall)
}

func (fake *FakeInstallationClient) CheckInstallationCalls(stub func(string) bool) {
	fake.checkInstallationMutex.Lock()
	defer fake.checkInstallationMutex.Unlock()
	fake.CheckInstallationStub = stub
}

func (fake *FakeInstallationClient) CheckInstallationArgsForCall(i int) string {
	fake.checkInstallationMutex.RLock()
	defer fake.checkInstallationMutex.RUnlock()
	argsForCall := fake.checkInstallationArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeInstallationClient) CheckInstallationReturns(result1 bool) {
	fake.checkInstallationMutex.Lock()
	defer fake.checkInstallationMutex.Unlock()
	fake.CheckInstallationStub = nil
	fake.checkInstallationReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeInstallationClient) CheckInstallationReturnsOnCall(i int, result1 bool) {
	fake.checkInstallationMutex.Lock()
	defer fake.checkInstallationMutex.Unlock()
	fake.CheckInstallationStub = nil
	if fake.checkInstallationReturnsOnCall == nil {
		fake.checkInstallationReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.checkInstallationReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeInstallationClient) GetComments(arg1 context.Context, arg2 string, arg3 string, arg4 int) ([]github.IssueComment, error) {
	fake.getCommentsMutex.Lock()
	ret, specificReturn := fake.getCommentsReturnsOnCall[len(fake.getCommentsArgsForCall)]
	fake.getCommentsArgsForCall = append(fake.getCommentsArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 int
	}{arg1, arg2, arg3, arg4})
	stub := fake.GetCommentsStub
	fakeReturns := fake.getCommentsReturns
	fake.recordInvocation("GetComments", []interface{}{arg1, arg2, arg3, arg4})
	fake.getCommentsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeInstallationClient) GetCommentsCallCount() int {
	fake.getCommentsMutex.RLock()
	defer fake.getCommentsMutex.RUnlock()
	return len(fake.getCommentsArgsForCall)
}

func (fake *FakeInstallationClient) GetCommentsCalls(stub func(context.Context, string, string, int) ([]github.IssueComment, error)) {
	fake.getCommentsMutex.Lock()
	defer fake.getCommentsMutex.Unlock()
	fake.GetCommentsStub = stub
}

func (fake *FakeInstallationClient) GetCommentsArgsForCall(i int) (context.Context, string, string, int) {
	fake.getCommentsMutex.RLock()
	defer fake.getCommentsMutex.RUnlock()
	argsForCall := fake.getCommentsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeInstallationClient) GetCommentsReturns(result1 []github.IssueComment, result2 error) {
	fake.getCommentsMutex.Lock()
	defer fake.getCommentsMutex.Unlock()
	fake.GetCommentsStub = nil
	fake.getCommentsReturns = struct {
		result1 []github.IssueComment
		result2 error
	}{result1, result2}
}

func (fake *FakeInstallationClient) GetCommentsReturnsOnCall(i int, result1 []github.IssueComment, result2 error) {
	fake.getCommentsMutex.Lock()
	defer fake.getCommentsMutex.Unlock()
	fake.GetCommentsStub = nil
	if fake.getCommentsReturnsOnCall == nil {
		fake.getCommentsReturnsOnCall = make(map[int]struct {
			result1 []github.IssueComment
			result2 error
		})
	}
	fake.getCommentsReturnsOnCall[i] = struct {
		result1 []github.IssueComment
		result2 error
	}{result1, result2}
}

func (fake *FakeInstallationClient) GetIssueEvents(arg1 context.Context, arg2 string, arg3 string, arg4 int) ([]github.IssueEvent, error) {
	fake.getIssueEventsMutex.Lock()
	ret, specificReturn := fake.getIssueEventsReturnsOnCall[len(fake.getIssueEventsArgsForCall)]
	fake.getIssueEventsArgsForCall = append(fake.getIssueEventsArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 int
	}{arg1, arg2, arg3, arg4})
	stub := fake.GetIssueEventsStub
	fakeReturns := fake.getIssueEventsReturns
	fake.recordInvocation("GetIssueEvents", []interface{}{arg1, arg2, arg3, arg4})
	fake.getIssueEventsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeInstallationClient) GetIssueEventsCallCount() int {
	fake.getIssueEventsMutex.RLock()
	defer fake.getIssueEventsMutex.RUnlock()
	return len(fake.getIssueEventsArgsForCall)
}

func (fake *FakeInstallationClient) GetIssueEventsCalls(stub func(context.Context, string, string, int) ([]github.IssueEvent, error)) {
	fake.getIssueEventsMutex.Lock()
	defer fake.getIssueEventsMutex.Unlock()
	fake.GetIssueEventsStub = stub
}

func (fake *FakeInstallationClient) GetIssueEventsArgsForCall(i int) (context.Context, string, string, int) {
	fake.getIssueEventsMutex.RLock()
	defer fake.getIssueEventsMutex.RUnlock()
	argsForCall := fake.getIssueEventsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeInstallationClient) GetIssueEventsReturns(result1 []github.IssueEvent, result2 error) {
	fake.getIssueEventsMutex.Lock()
	defer fake.getIssueEventsMutex.Unlock()
	fake.GetIssueEventsStub = nil
	fake.getIssueEventsReturns = struct {
		result1 []github.IssueEvent
		result2 error
	}{result1, result2}
}

func (fake *FakeInstallationClient) GetIssueEventsReturnsOnCall(i int, result1 []github.IssueEvent, result2 error) {
	fake.getIssueEventsMutex.Lock()
	defer fake.getIssueEventsMutex.Unlock()
	fake.GetIssueEventsStub = nil
	if fake.getIssueEventsReturnsOnCall == nil {
		fake.getIssueEventsReturnsOnCall = make(map[int]struct {
			result1 []github.IssueEvent
			result2 error
		})
	}
	fake.getIssueEventsReturnsOnCall[i] = struct {
		result1 []github.IssueEvent
		result2 error
	}{result1, result2}
}

func (fake *FakeInstallationClient) GetIssuePullRequest(arg1 context.Context, arg2 string, arg3 string, arg4 int) (*github.PullRequest, error) {
	fake.getIssuePullRequestMutex.Lock()
	ret, specificReturn := fake.getIssuePullRequestReturnsOnCall[len(fake.getIssuePullRequestArgsForCall)]
	fake.getIssuePullRequestArgsForCall = append(fake.getIssuePullRequestArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 int
	}{arg1, arg2, arg3, arg4})
	stub := fake.GetIssuePullRequestStub
	fakeReturns := fake.getIssuePullRequestReturns
	fake.recordInvocation("GetIssuePullRequest", []interface{}{arg1, arg2, arg3, arg4})
	fake.getIssuePullRequestMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeInstallationClient) GetIssuePullRequestCallCount() int {
	fake.getIssuePullRequestMutex.RLock()
	defer fake.getIssuePullRequestMutex.RUnlock()
	return len(fake.getIssuePullRequestArgsForCall)
}

func (fake *FakeInstallationClient) GetIssuePullRequestCalls(stub func(context.Context, string, string, int) (*github.PullRequest, error)) {
	fake.getIssuePullRequestMutex.Lock()
	defer fake.getIssuePullRequestMutex.Unlock()
	fake.GetIssuePullRequestStub = stub
}

func (fake *FakeInstallationClient) GetIssuePullRequestArgsForCall(i int) (context.Context, string, string, int) {
	fake.getIssuePullRequestMutex.RLock()
	defer fake.getIssuePullRequestMutex.RUnlock()
	argsForCall := fake.getIssuePullRequestArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeInstallationClient) GetIssuePullRequestReturns(result1 *github.PullRequest, result2 error) {
	fake.getIssuePullRequestMutex.Lock()
	defer fake.getIssuePullRequestMutex.Unlock()
	fake.GetIssuePullRequestStub = nil
	fake.getIssuePullRequestReturns = struct {
		result1 *github.PullRequest
		result2 error
	}{result1, result2}
}

func (fake *FakeInstallationClient) GetIssuePullRequestReturnsOnCall(i int, result1 *github.PullRequest, result2 error) {
	fake.getIssuePullRequestMutex.Lock()
	defer fake.getIssuePullRequestMutex.Unlock()
	fake.GetIssuePullRequestStub = nil
	if fake.getIssuePullRequestReturnsOnCall == nil {
		fake.getIssuePullRequestReturnsOnCall = make(map[int]struct {
			result1 *github.PullRequest
			result2 error
		})
	}
	fake.getIssuePullRequestReturnsOnCall[i] = struct {
		result1 *github.PullRequest
		result2 error
	}{result1, result2}
}

func (fake *FakeInstallationClient) GetIssuesByRepo(arg1 context.Context, arg2 string, arg3 string, arg4 []string, arg5 *github.IssueState) ([]github.Issue, error) {
	var arg4Copy []string
	if arg4 != nil {
		arg4Copy = make([]string, len(arg4))
		copy(arg4Copy, arg4)
	}
	fake.getIssuesByRepoMutex.Lock()
	ret, specificReturn := fake.getIssuesByRepoReturnsOnCall[len(fake.getIssuesByRepoArgsForCall)]
	fake.getIssuesByRepoArgsForCall = append(fake.getIssuesByRepoArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 []string
		arg5 *github.IssueState
	}{arg1, arg2, arg3, arg4Copy, arg5})
	stub := fake.GetIssuesByRepoStub
	fakeReturns := fake.getIssuesByRepoReturns
	fake.recordInvocation("GetIssuesByRepo", []interface{}{arg1, arg2, arg3, arg4Copy, arg5})
	fake.getIssuesByRepoMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeInstallationClient) GetIssuesByRepoCallCount() int {
	fake.getIssuesByRepoMutex.RLock()
	defer fake.getIssuesByRepoMutex.RUnlock()
	return len(fake.getIssuesByRepoArgsForCall)
}

func (fake *FakeInstallationClient) GetIssuesByRepoCalls(stub func(context.Context, string, string, []string, *github.IssueState) ([]github.Issue, error)) {
	fake.getIssuesByRepoMutex.Lock()
	defer fake.getIssuesByRepoMutex.Unlock()
	fake.GetIssuesByRepoStub = stub
}

func (fake *FakeInstallationClient) GetIssuesByRepoArgsForCall(i int) (context.Context, string, string, []string, *github.IssueState) {
	fake.getIssuesByRepoMutex.RLock()
	defer fake.getIssuesByRepoMutex.RUnlock()
	argsForCall := fake.getIssuesByRepoArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeInstallationClient) GetIssuesByRepoReturns(result1 []github.Issue, result2 error) {
	fake.getIssuesByRepoMutex.Lock()
	defer fake.getIssuesByRepoMutex.Unlock()
	fake.GetIssuesByRepoStub = nil
	fake.getIssuesByRepoReturns = struct {
		result1 []github.Issue
		result2 error
	}{result1, result2}
}

func (fake *FakeInstallationClient) GetIssuesByRepoReturnsOnCall(i int, result1 []github.Issue, result2 error) {
	fake.getIssuesByRepoMutex.Lock()
	defer fake.getIssuesByRepoMutex.Unlock()
	fake.GetIssuesByRepoStub = nil
	if fake.getIssuesByRepoReturnsOnCall == nil {
		fake.getIssuesByRepoReturnsOnCall = make(map[int]struct {
			result1 []github.Issue
			result2 error
		})
	}
	fake.getIssuesByRepoReturnsOnCall[i] = struct {
		result1 []github.Issue
		result2 error
	}{result1, result2}
}

func (fake *FakeInstallationClient) GetRateLimit(arg1 context.Context, arg2 string) (github.RateLimit, error) {
	fake.getRateLimitMutex.Lock()
	ret, specificReturn := fake.getRateLimitReturnsOnCall[len(fake.getRateLimitArgsForCall)]
	fake.getRateLimitArgsForCall = append(fake.getRateLimitArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.GetRateLimitStub
	fakeReturns := fake.getRateLimitReturns
	fake.recordInvocation("GetRateLimit", []interface{}{arg1, arg2})
	fake.getRateLimitMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeInstallationClient) GetRateLimitCallCount() int {
	fake.getRateLimitMutex.RLock()
	defer fake.getRateLimitMutex.RUnlock()
	return len(fake.getRateLimitArgsForCall)
}

func (fake *FakeInstallationClient) GetRateLimitCalls(stub func(context.Context, string) (github.RateLimit, error)) {
	fake.getRateLimitMutex.Lock()
	defer fake.getRateLimitMutex.Unlock()
	fake.GetRateLimitStub = stub
}

func (fake *FakeInstallationClient) GetRateLimitArgsForCall(i int) (context.Context, string) {
	fake.getRateLimitMutex.RLock()
	defer fake.getRateLimitMutex.RUnlock()
	argsForCall := fake.getRateLimitArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeInstallationClient) GetRateLimitReturns(result1 github.RateLimit, result2 error) {
	fake.getRateLimitMutex.Lock()
	defer fake.getRateLimitMutex.Unlock()
	fake.GetRateLimitStub = nil
	fake.getRateLimitReturns = struct {
		result1 github.RateLimit
		result2 error
	}{result1, result2}
}

func (fake *FakeInstallationClient) GetRateLimitReturnsOnCall(i int, result1 github.RateLimit, result2 error) {
	fake.getRateLimitMutex.Lock()
	defer fake.getRateLimitMutex.Unlock()
	fake.GetRateLimitStub = nil
	if fake.getRateLimitReturnsOnCall == nil {
		fake.getRateLimitReturnsOnCall = make(map[int]struct {
			result1 github.RateLimit
			result2 error
		})
	}
	fake.getRateLimitReturnsOnCall[i] = struct {
		result1 github.RateLimit
		result2 error
	}{result1, result2}
}

func (fake *FakeInstallationClient) GetRepos(arg1 context.Context, arg2 string) ([]github.Repo, error) {
	fake.getReposMutex.Lock()
	ret, specificReturn := fake.getReposReturnsOnCall[len(fake.getReposArgsForCall)]
	fake.getReposArgsForCall = append(fake.getReposArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.GetReposStub
	fakeReturns := fake.getReposReturns
	fake.recordInvocation("GetRepos", []interface{}{arg1, arg2})
	fake.getReposMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeInstallationClient) GetReposCallCount() int {
	fake.getReposMutex.RLock()
	defer fake.getReposMutex.RUnlock()
	return len(fake.getReposArgsForCall)
}

func (fake *FakeInstallationClient) GetReposCalls(stub func(context.Context, string) ([]github.Repo, error)) {
	fake.getReposMutex.Lock()
	defer fake.getReposMutex.Unlock()
	fake.GetReposStub = stub
}

func (fake *FakeInstallationClient) GetReposArgsForCall(i int) (context.Context, string) {
	fake.getReposMutex.RLock()
	defer fake.getReposMutex.RUnlock()
	argsForCall := fake.getReposArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeInstallationClient) GetReposReturns(result1 []github.Repo, result2 error) {
	fake.getReposMutex.Lock()
	defer fake.getReposMutex.Unlock()
	fake.GetReposStub = nil
	fake.getReposReturns = struct {
		result1 []github.Repo
		result2 error
	}{result1, result2}
}

func (fake *FakeInstallationClient) GetReposReturnsOnCall(i int, result1 []github.Repo, result2 error) {
	fake.getReposMutex.Lock()
	defer fake.getReposMutex.Unlock()
	fake.GetReposStub = nil
	if fake.getReposReturnsOnCall == nil {
		fake.getReposReturnsOnCall = make(map[int]struct {
			result1 []github.Repo
			result2 error
		})
	}
	fake.getReposReturnsOnCall[i] = struct {
		result1 []github.Repo
		result2 error
	}{result1, result2}
}

func (fake *FakeInstallationClient) GetUser(arg1 context.Context, arg2 string, arg3 string) (github.User, error) {
	fake.getUserMutex.Lock()
	ret, specificReturn := fake.getUserReturnsOnCall[len(fake.getUserArgsForCall)]
	fake.getUserArgsForCall = append(fake.getUserArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.GetUserStub
	fakeReturns := fake.getUserReturns
	fake.recordInvocation("GetUser", []interface{}{arg1, arg2, arg3})
	fake.getUserMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeInstallationClient) GetUserCallCount() int {
	fake.getUserMutex.RLock()
	defer fake.getUserMutex.RUnlock()
	return len(fake.getUserArgsForCall)
}

func (fake *FakeInstallationClient) GetUserCalls(stub func(context.Context, string, string) (github.User, error)) {
	fake.getUserMutex.Lock()
	defer fake.getUserMutex.Unlock()
	fake.GetUserStub = stub
}

func (fake *FakeInstallationClient) GetUserArgsForCall(i int) (context.Context, string, string) {
	fake.getUserMutex.RLock()
	defer fake.getUserMutex.RUnlock()
	argsForCall := fake.getUserArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeInstallationClient) GetUserReturns(result1 github.User, result2 error) {
	fake.getUserMutex.Lock()
	defer fake.getUserMutex.Unlock()
	fake.GetUserStub = nil
	fake.getUserReturns = struct {
		result1 github.User
		result2 error
	}{result1, result2}
}

func (fake *FakeInstallationClient) GetUserReturnsOnCall(i int, result1 github.User, result2 error) {
	fake.getUserMutex.Lock()
	defer fake.getUserMutex.Unlock()
	fake.GetUserStub = nil
	if fake.getUserReturnsOnCall == nil {
		fake.getUserReturnsOnCall = make(map[int]struct {
			result1 github.User
			result2 error
		})
	}
	fake.getUserReturnsOnCall[i] = struct {
		result1 github.User
		result2 error
	}{result1, result2}
}

func (fake *FakeInstallationClient) PostComment(arg1 context.Context, arg2 string, arg3 string, arg4 int, arg5 string) error {
	fake.postCommentMutex.Lock()
	ret, specificReturn := fake.postCommentReturnsOnCall[len(fake.postCommentArgsForCall)]
	fake.postCommentArgsForCall = append(fake.postCommentArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 int
		arg5 string
	}{arg1, arg2, arg3, arg4, arg5})
	stub := fake.PostCommentStub
	fakeReturns := fake.postCommentReturns
	fake.recordInvocation("PostComment", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.postCommentMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeInstallationClient) PostCommentCallCount() int {
	fake.postCommentMutex.RLock()
	defer fake.postCommentMutex.RUnlock()
	return len(fake.postCommentArgsForCall)
}

func (fake *FakeInstallationClient) PostCommentCalls(stub func(context.Context, string, string, int, string) error) {
	fake.postCommentMutex.Lock()
	defer fake.postCommentMutex.Unlock()
	fake.PostCommentStub = stub
}

func (fake *FakeInstallationClient) PostCommentArgsForCall(i int) (context.Context, string, string, int, string) {
	fake.postCommentMutex.RLock()
	defer fake.postCommentMutex.RUnlock()
	argsForCall := fake.postCommentArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeInstallationClient) PostCommentReturns(result1 error) {
	fake.postCommentMutex.Lock()
	defer fake.postCommentMutex.Unlock()
	fake.PostCommentStub = nil
	fake.postCommentReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeInstallationClient) PostCommentReturnsOnCall(i int, result1 error) {
	fake.postCommentMutex.Lock()
	defer fake.postCommentMutex.Unlock()
	fake.PostCommentStub = nil
	if fake.postCommentReturnsOnCall == nil {
		fake.postCommentReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.postCommentReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeInstallationClient) PostLabel(arg1 context.Context, arg2 string, arg3 string, arg4 github.Label) error {
	fake.postLabelMutex.Lock()
	ret, specificReturn := fake.postLabelReturnsOnCall[len(fake.postLabelArgsForCall)]
	fake.postLabelArgsForCall = append(fake.postLabelArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 github.Label
	}{arg1, arg2, arg3, arg4})
	stub := fake.PostLabelStub
	fakeReturns := fake.postLabelReturns
	fake.recordInvocation("PostLabel", []interface{}{arg1, arg2, arg3, arg4})
	fake.postLabelMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeInstallationClient) PostLabelCallCount() int {
	fake.postLabelMutex.RLock()
	defer fake.postLabelMutex.RUnlock()
	return len(fake.postLabelArgsForCall)
}

func (fake *FakeInstallationClient) PostLabelCalls(stub func(context.Context, string, string, github.Label) error) {
	fake.postLabelMutex.Lock()
	defer fake.postLabelMutex.Unlock()
	fake.PostLabelStub = stub
}

func (fake *FakeInstallationClient) PostLabelArgsForCall(i int) (context.Context, string, string, github.Label) {
	fake.postLabelMutex.RLock()
	defer fake.postLabelMutex.RUnlock()
	argsForCall := fake.postLabelArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeInstallationClient) PostLabelReturns(result1 error) {
	fake.postLabelMutex.Lock()
	defer fake.postLabelMutex.Unlock()
	fake.PostLabelStub = nil
	fake.postLabelReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeInstallationClient) PostLabelReturnsOnCall(i int, result1 error) {
	fake.postLabelMutex.Lock()
	defer fake.postLabelMutex.Unlock()
	fake.PostLabelStub = nil
	if fake.postLabelReturnsOnCall == nil {
		fake.postLabelReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.postLabelReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeInstallationClient) PostLabels(arg1 context.Context, arg2 string, arg3 []string, arg4 map[string]github.Label) []error {
	var arg3Copy []string
	if arg3 != nil {
		arg3Copy = make([]string, len(arg3))
		copy(arg3Copy, arg3)
	}
	fake.postLabelsMutex.Lock()
	ret, specificReturn := fake.postLabelsReturnsOnCall[len(fake.postLabelsArgsForCall)]
	fake.postLabelsArgsForCall = append(fake.postLabelsArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 []string
		arg4 map[string]github.Label
	}{arg1, arg2, arg3Copy, arg4})
	stub := fake.PostLabelsStub
	fakeReturns := fake.postLabelsReturns
	fake.recordInvocation("PostLabels", []interface{}{arg1, arg2, arg3Copy, arg4})
	fake.postLabelsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeInstallationClient) PostLabelsCallCount() int {
	fake.postLabelsMutex.RLock()
	defer fake.postLabelsMutex.RUnlock()
	return len(fake.postLabelsArgsForCall)
}

func (fake *FakeInstallationClient) PostLabelsCalls(stub func(context.Context, string, []string, map[string]github.Label) []error) {
	fake.postLabelsMutex.Lock()
	defer fake.postLabelsMutex.Unlock()
	fake.PostLabelsStub = stub
}

func (fake *FakeInstallationClient) PostLabelsArgsForCall(i int) (context.Context, string, []string, map[string]github.Label) {
	fake.postLabelsMutex.RLock()
	defer fake.postLabelsMutex.RUnlock()
	argsForCall := fake.postLabelsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeInstallationClient) PostLabelsReturns(result1 []error) {
	fake.postLabelsMutex.Lock()
	defer fake.postLabelsMutex.Unlock()
	fake.PostLabelsStub = nil
	fake.postLabelsReturns = struct {
		result1 []error
	}{result1}
}

func (fake *FakeInstallationClient) PostLabelsReturnsOnCall(i int, result1 []error) {
	fake.postLabelsMutex.Lock()
	defer fake.postLabelsMutex.Unlock()
	fake.PostLabelsStub = nil
	if fake.postLabelsReturnsOnCall == nil {
		fake.postLabelsReturnsOnCall = make(map[int]struct {
			result1 []error
		})
	}
	fake.postLabelsReturnsOnCall[i] = struct {
		result1 []error
	}{result1}
}

func (fake *FakeInstallationClient) UpdateComment(arg1 context.Context, arg2 string, arg3 string, arg4 int64, arg5 string) error {
	fake.updateCommentMutex.Lock()
	ret, specificReturn := fake.updateCommentReturnsOnCall[len(fake.updateCommentArgsForCall)]
	fake.updateCommentArgsForCall = append(fake.updateCommentArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 int64
		arg5 string
	}{arg1, arg2, arg3, arg4, arg5})
	stub := fake.UpdateCommentStub
	fakeReturns := fake.updateCommentReturns
	fake.recordInvocation("UpdateComment", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.updateCommentMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeInstallationClient) UpdateCommentCallCount() int {
	fake.updateCommentMutex.RLock()
	defer fake.updateCommentMutex.RUnlock()
	return len(fake.updateCommentArgsForCall)
}

func (fake *FakeInstallationClient) UpdateCommentCalls(stub func(context.Context, string, string, int64, string) error) {
	fake.updateCommentMutex.Lock()
	defer fake.updateCommentMutex.Unlock()
	fake.UpdateCommentStub = stub
}

func (fake *FakeInstallationClient) UpdateCommentArgsForCall(i int) (context.Context, string, string, int64, string) {
	fake.updateCommentMutex.RLock()
	defer fake.updateCommentMutex.RUnlock()
	argsForCall := fake.updateCommentArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeInstallationClient) UpdateCommentReturns(result1 error) {
	fake.updateCommentMutex.Lock()
	defer fake.updateCommentMutex.Unlock()
	fake.UpdateCommentStub = nil
	fake.updateCommentReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeInstallationClient) UpdateCommentReturnsOnCall(i int, result1 error) {
	fake.updateCommentMutex.Lock()
	defer fake.updateCommentMutex.Unlock()
	fake.UpdateCommentStub = nil
	if fake.updateCommentReturnsOnCall == nil {
		fake.updateCommentReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.updateCommentReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeInstallationClient) ValidateWebHookEvent(arg1 *http.Request) (interface{}, error) {
	fake.validateWebHookEventMutex.Lock()
	ret, specificReturn := fake.validateWebHookEventReturnsOnCall[len(fake.validateWebHookEventArgsForCall)]
	fake.validateWebHookEventArgsForCall = append(fake.validateWebHookEventArgsForCall, struct {
		arg1 *http.Request
	}{arg1})
	stub := fake.ValidateWebHookEventStub
	fakeReturns := fake.validateWebHookEventReturns
	fake.recordInvocation("ValidateWebHookEvent", []interface{}{arg1})
	fake.validateWebHookEventMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeInstallationClient) ValidateWebHookEventCallCount() int {
	fake.validateWebHookEventMutex.RLock()
	defer fake.validateWebHookEventMutex.RUnlock()
	return len(fake.validateWebHookEventArgsForCall)
}

func (fake *FakeInstallationClient) ValidateWebHookEventCalls(stub func(*http.Request) (interface{}, error)) {
	fake.validateWebHookEventMutex.Lock()
	defer fake.validateWebHookEventMutex.Unlock()
	fake.ValidateWebHookEventStub = stub
}

func (fake *FakeInstallationClient) ValidateWebHookEventArgsForCall(i int) *http.Request {
	fake.validateWebHookEventMutex.RLock()
	defer fake.validateWebHookEventMutex.RUnlock()
	argsForCall := fake.validateWebHookEventArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeInstallationClient) ValidateWebHookEventReturns(result1 interface{}, result2 error) {
	fake.validateWebHookEventMutex.Lock()
	defer fake.validateWebHookEventMutex.Unlock()
	fake.ValidateWebHookEventStub = nil
	fake.validateWebHookEventReturns = struct {
		result1 interface{}
		result2 error
	}{result1, result2}
}

func (fake *FakeInstallationClient) ValidateWebHookEventReturnsOnCall(i int, result1 interface{}, result2 error) {
	fake.validateWebHookEventMutex.Lock()
	defer fake.validateWebHookEventMutex.Unlock()
	fake.ValidateWebHookEventStub = nil
	if fake.validateWebHookEventReturnsOnCall == nil {
		fake.validateWebHookEventReturnsOnCall = make(map[int]struct {
			result1 interface{}
			result2 error
		})
	}
	fake.validateWebHookEventReturnsOnCall[i] = struct {
		result1 interface{}
		result2 error
	}{result1, result2}
}

func (fake *FakeInstallationClient) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.addInstallationMutex.RLock()
	defer fake.addInstallationMutex.RUnlock()
	fake.checkInstallationMutex.RLock()
	defer fake.checkInstallationMutex.RUnlock()
	fake.getCommentsMutex.RLock()
	defer fake.getCommentsMutex.RUnlock()
	fake.getIssueEventsMutex.RLock()
	defer fake.getIssueEventsMutex.RUnlock()
	fake.getIssuePullRequestMutex.RLock()
	defer fake.getIssuePullRequestMutex.RUnlock()
	fake.getIssuesByRepoMutex.RLock()
	defer fake.getIssuesByRepoMutex.RUnlock()
	fake.getRateLimitMutex.RLock()
	defer fake.getRateLimitMutex.RUnlock()
	fake.getReposMutex.RLock()
	defer fake.getReposMutex.RUnlock()
	fake.getUserMutex.RLock()
	defer fake.getUserMutex.RUnlock()
	fake.postCommentMutex.RLock()
	defer fake.postCommentMutex.RUnlock()
	fake.postLabelMutex.RLock()
	defer fake.postLabelMutex.RUnlock()
	fake.postLabelsMutex.RLock()
	defer fake.postLabelsMutex.RUnlock()
	fake.updateCommentMutex.RLock()
	defer fake.updateCommentMutex.RUnlock()
	fake.validateWebHookEventMutex.RLock()
	defer fake.validateWebHookEventMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeInstallationClient) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ github.InstallationClient = new(FakeInstallationClient)
